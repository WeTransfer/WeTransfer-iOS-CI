# rubocop:disable LineLength
desc 'Runs tests for an external project'
lane :test_project do |options|
	clear_derived_data

	# Clean old reports so they're not reported for no reason.
	reports_dir = "./../build/reports"
	FileUtils.rm_rf Dir.glob("#{reports_dir}/*") if File.directory?(reports_dir)

	# Set timeout to prevent xcodebuild -list -project to take to much retries.
	ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

	begin
		ENV["XCPRETTY_JSON_FILE_OUTPUT"] = "build/reports/#{options[:scheme]}_Tests.json"
		source_dir = ENV['BITRISE_SOURCE_DIR'] || '.'
		device = options[:device] || "iPhone 11"
		scan(
		  scheme: options[:scheme],
		  project: "#{options[:project_path]}#{options[:project_name]}.xcodeproj",
		  device: device,
		  destination: options[:destination],
		  #clean: true,
		  #force_quit_simulator: true,
		  code_coverage: true,
		  #disable_concurrent_testing: true,
		  fail_build: false,
		  skip_slack: true,
		  output_types: "",
		  xcargs: "-UseNewBuildSystem=YES",
		  include_simulator_logs: false, # Needed for this: https://github.com/fastlane/fastlane/issues/8909
		  formatter: "xcpretty-json-formatter",
		  result_bundle: true,
		  output_directory: "build/reports/"
		)
	rescue => ex
		UI.important("Tests failed for #{ex}")
	end
end

desc 'Tests the WeTransferPRLinter Swift Package'
lane :test_pr_linter do |options|
	spm(command: "generate-xcodeproj", package_path: "Danger-Swift")
	test_project(
		project_path: "Danger-Swift/", 
		project_name: "WeTransferPRLinter", 
		scheme: "WeTransferPRLinter-Package",
		device: nil,
		destination: "platform=macOS")
end

desc 'Create a release from a tag triggered CI run'
lane :release_from_tag do |options|
	# Get the latest tag, which is the new release that triggered this lane.
	sh "git fetch --tags origin #{ENV["BITRISE_GIT_BRANCH"]} --no-recurse-submodules"
    
    released_tag = sh("git tag --sort=committerdate | tail -1").strip
	previous_tag = sh("git describe --abbrev=0 --tags `git rev-list --tags --skip=1  --max-count=1`").strip
    
	# Get the changelog
    changelog = current_changelog(since_tag: previous_tag)

    # Stop if there's no changelog
    next unless !changelog.strip!.empty?
    
    # Create a release on Github with the changelog
    title = "#{released_tag}"
    # release_url = create_github_release(title: title, tag_name: released_tag, changelog: changelog)

    # puts "Created release: #{release_url}"

	# Create a release branch
	# sh "git branch release/#{released_tag} origin/master"
 #    sh "git checkout release/#{released_tag}"
 #    sh "git merge -X theirs #{released_tag}"

	# Update the changelog
	create_changelog_release(release_title: title)

	# Find the podspec file in directory ..
	podspec_path = ..

	# Update the podspec
	version_bump_podspec(path: podspec_path, version_number: released_tag)
	# Push the podspec to trunk

	# Push the changes to the branch

	# Create a PR
end

desc "Create a new release on Github"
desc ""
desc "- Uses the changelog as description of the new release"
lane :create_github_release do |options|
  title = options[:title]
  tag_name = options[:tag_name]
  commitish = sh "git rev-parse HEAD"
  repository_name = sh("git remote show origin -n | ruby -ne 'puts /^\s*Fetch.*:(.*).git/.match($_)[1] rescue nil'").strip

  puts "Creating Github Release '#{title} for repository #{repository_name}"

  changelog = options[:changelog] || current_changelog

  github_release = set_github_release(
    repository_name: repository_name,
    api_token: ENV["DANGER_GITHUB_API_TOKEN"],
    name: title,
    tag_name: tag_name,
    description: changelog,
    commitish: commitish.strip,
    is_draft: false,
    is_prerelease: options[:is_prerelease] || false
  )
  github_release["html_url"]
end

desc "Appends the current open changes to the Changelog.md. Returns the appended changelog lines"
lane :create_changelog_release do |options|
  release_title = options[:release_title]

  changelog_path = options[:changelog_path] || '../Changelog.md'
  existing_changelog = File.read(changelog_path)
  new_changelog = current_changelog

  File.open(changelog_path, 'w') { |file| 
    file << "# #{release_title}\n" + "\n"
    file << new_changelog + "\n"
    file << existing_changelog
  }
  new_changelog
end

desc "Get the current changes since the last non-draft release"
lane :current_changelog do |options|
	puts "Fetching changelog for base branch #{options[:base_branch]}"
	latest_release_tag = options[:since_tag] || latest_github_release
	base_branch = options[:base_branch] || "master"
	changelog = sh("changelogproducer -b #{base_branch} -s #{latest_release_tag}")
end

desc "Get latest Coyote release from Github. Draft releases and prereleases are not returned by this endpoint. See: https://developer.github.com/v3/repos/releases/#get-the-latest-release"
lane :latest_github_release do
	origin_name = sh("git remote show origin -n | ruby -ne 'puts /^\s*Fetch.*:(.*).git/.match($_)[1] rescue nil'").split('/')
	organisation = origin_name[0].strip
	repository = origin_name[1].strip

	result = github_api(
		server_url: "https://api.github.com",
		api_token: ENV["DANGER_GITHUB_API_TOKEN"],
		http_method: "GET",
		path: "/repos/#{organisation}/#{repository}/releases/latest"
	)

	puts "Latest Github release is #{result[:json]["tag_name"]}"
	result[:json]["tag_name"]
end
