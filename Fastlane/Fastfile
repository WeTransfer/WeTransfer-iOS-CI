# rubocop:disable LineLength

require "uri"

desc 'Runs tests for a specific package'
lane :test_package do |options|	
	# Set timeout to prevent xcodebuild -list -project to take to much retries.
	ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
	ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

	begin
		reports_dir = "#{ENV['PWD']}/build/reports"

		ENV["XCPRETTY_JSON_FILE_OUTPUT"] = "#{reports_dir}/#{options[:package_name]}_Tests.json"

		# This does not work yet, see: https://github.com/fastlane/fastlane/issues/17734
		# device = options[:device] || "iPhone 11"
		# scan(
		#   scheme: options[:package_name],
		#   xcodebuild_command: "cd #{ENV['PWD']}/#{options[:package_path]} && env NSUnbufferedIO=YES xcodebuild",
		#   device: device,
		#   code_coverage: true,
		#   disable_concurrent_testing: true,
		#   fail_build: false,
		#   skip_slack: true,
		#   output_types: "",
		#   prelaunch_simulator: true,
		#   xcargs: "-UseNewBuildSystem=YES",
		#   include_simulator_logs: false, # Needed for this: https://github.com/fastlane/fastlane/issues/8909
		#   formatter: "xcpretty-json-formatter",
		#   result_bundle: true,
		#   output_directory: "build/reports/",
		#   cloned_source_packages_path: "SourcePackages",
		#   disable_package_automatic_updates: true
		# )

		destination = 'platform=iOS Simulator,name=iPhone 11'
		sourcePackagesDir = "#{ENV['PWD']}/SourcePackages"

		disable_automatic_package_resolution = options.fetch(:disable_automatic_package_resolution, true)
		extra_flags = disable_automatic_package_resolution ? "-disableAutomaticPackageResolution" : ""

		# Set the result bundle path and delete an existing one if needed.
		result_bundle_path = "#{reports_dir}/#{options[:package_name]}.xcresult"
		FileUtils.remove_dir(result_bundle_path) if File.exist?(result_bundle_path)

		#sh "cd #{ENV['PWD']}/#{options[:package_path]} && xcodebuild -showBuildSettings -clonedSourcePackagesDirPath #{sourcePackagesDir} -verbose"
	    sh "cd #{ENV['PWD']}/#{options[:package_path]} && xcodebuild -scheme #{options[:package_name]} -destination '#{destination}' -verbose -resultBundlePath '#{result_bundle_path}' -disable-concurrent-testing -enableCodeCoverage YES -UseNewBuildSystem=YES -clonedSourcePackagesDirPath #{sourcePackagesDir} #{extra_flags} test | xcpretty -f `xcpretty-json-formatter`"
	rescue => ex
		UI.important("Tests failed for #{ex}")
	end
end

desc 'Runs tests for an external project'
lane :test_project do |options|
	clear_derived_data

	# Set timeout to prevent xcodebuild -list -project to take to much retries.
	ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
	ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

	begin
		ENV["XCPRETTY_JSON_FILE_OUTPUT"] = "build/reports/#{options[:scheme]}_Tests.json"

		device = options[:device] || "iPhone 11"
		scan(
		  scheme: options[:scheme],
		  project: "#{options[:project_path]}#{options[:project_name]}.xcodeproj",
		  device: device,
		  destination: options[:destination],
		  code_coverage: true,
		  disable_concurrent_testing: true,
		  fail_build: false,
		  skip_slack: true,
		  output_types: "",
		  prelaunch_simulator: true,
		  xcargs: "-UseNewBuildSystem=YES",
		  include_simulator_logs: false, # Needed for this: https://github.com/fastlane/fastlane/issues/8909
		  formatter: "xcpretty-json-formatter",
		  result_bundle: true,
		  output_directory: "build/reports/",
		  cloned_source_packages_path: "SourcePackages"
		)
	rescue => ex
		UI.important("Tests failed for #{ex}")
	end
end

desc 'Tests the WeTransferPRLinter Swift Package'
lane :test_pr_linter do |options|
	spm(command: "generate-xcodeproj", package_path: "Danger-Swift")
	test_project(
		project_path: "Danger-Swift/", 
		project_name: "WeTransferPRLinter", 
		scheme: "WeTransferPRLinter-Package",
		device: nil,
		destination: "platform=macOS")
end

desc 'Create a release from a tag triggered CI run'
lane :release_from_tag do |options|
	# Get the latest tag, which is the new release that triggered this lane.
	sh('git fetch --tags origin master --no-recurse-submodules -q')

	latest_tag = ENV["BITRISE_GIT_TAG"]
	
	# Create a release branch
	sh "git branch release/#{latest_tag} origin/master"
    sh "git checkout release/#{latest_tag}"
    sh "git merge -X theirs #{latest_tag}"

	release_output = sh('gitbuddy release -c "../Changelog.md"')
	release_url = URI.extract(release_output).find { |url| url.include? 'releases/tag' }
    puts "Created release with URL: #{release_url}"

	# Run only if there's a podspec to update
	if Dir['../*.podspec'].any?
		# Update the podspec. It finds the .podspec automatically in the current folder.
		version_bump_podspec(version_number: latest_tag)
		
		begin
			# Push the podspec to trunk
			pod_push
		rescue => ex
			UI.important("Pod push failed: #{ex}")
		end
	end 

	# Push the changes to the branch
	sh('git commit -a -m "Created a new release"')
    sh("git push origin release/#{latest_tag}")
	
	# Create a PR
    # Create a pull request for master to include the updated Changelog.md and podspec
    create_pull_request(
      api_token: ENV["DANGER_GITHUB_API_TOKEN"],
      repo: git_repository_name,
      title: "Merge release #{latest_tag} into master",
      base: "master", # The branch to merge the changes into.
      body: "Containing all the changes for our [**#{latest_tag} Release**](#{release_url})."
    )
end

desc "Unhide dev dependencies for danger"
lane :unhide_spm_package_dev_dependencies do 
	text = File.read('../Package.swift')
	new_contents = text.gsub('// dev ', "")

	# To write changes to the file, use:
	File.open('../Package.swift', "w") {|file| file.puts new_contents }
end

desc "Returns the repository name. E.g: WeTransfer/Mocker"
lane :git_repository_name do
	sh("git remote show origin -n | grep h.URL | sed 's/.*://;s/.git$//'").strip
end

desc "Get latest Coyote release from Github. Draft releases and prereleases are not returned by this endpoint. See: https://developer.github.com/v3/repos/releases/#get-the-latest-release"
lane :latest_github_release do
	origin_name = git_repository_name.split('/')
	organisation = origin_name[0]
	repository = origin_name[1]

	result = github_api(
		server_url: "https://api.github.com",
		api_token: ENV["DANGER_GITHUB_API_TOKEN"],
		http_method: "GET",
		path: "/repos/#{organisation}/#{repository}/releases/latest"
	)

	puts "Latest Github release is #{result[:json]["tag_name"]}"
	result[:json]["tag_name"]
end

desc "Get all changed files in the current PR"
lane :changed_files_in_pr do |options|
	origin_name = git_repository_name.split('/')
	organisation = origin_name[0]
	repository = origin_name[1]

	if options[:pr_id].nil?
		raise "Missing PR ID input"
	elsif ENV["DANGER_GITHUB_API_TOKEN"].nil?
		raise "Missing 'DANGER_GITHUB_API_TOKEN' environment variable"
	end

	puts "Fetching changed files for PR #{options[:pr_id]} using token ...#{ENV["DANGER_GITHUB_API_TOKEN"].chars.last(5).join}"

	result = github_api(
		server_url: "https://api.github.com",
		api_token: ENV["DANGER_GITHUB_API_TOKEN"],
		http_method: "GET",
		path: "/repos/#{organisation}/#{repository}/pulls/#{options[:pr_id]}"
	)

	baseRef = result[:json]["base"]["ref"]

	# As CI fetches only the minimum we need to fetch the remote to make diffing work correctly.
	sh 'git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"'
	sh "git fetch --no-recurse-submodules --no-tags"
	sh "git diff --name-only HEAD origin/#{baseRef}"
end

desc "Check whether any of the changes happened in the given path"
lane :pr_changes_contains_path do |options|
  changes_contains_path = options[:changed_files].include?(options[:path])

  if changes_contains_path
  	puts "Changes found for path #{options[:path]}"
  elsif
	puts "No changes found for path #{options[:path]}"
  end
  	
  changes_contains_path
end

desc "Updates the build number of the project based on the commit count"
desc ""
desc "Options"
desc "- xcodeproj: the path to the Xcode project to read the version number from"
desc "- target: The target within the project to read the version number from"
desc "When no paramaters are passed you will be prompted."
lane :update_build_number do |options|
	# Get the path to the Xcode project and the target to read the version number from.
	xcodeproj = options[:xcodeproj]
	target = options[:target]

  # Compute a new build number based on the commit count.
	build = sh "git rev-list --all --count"
  new_build_number = 200 + Integer(build)

	# Fetch the build number of the most recent test flight build, to make sure
	# that the new build number will be higher.
  version_number = get_version_number(xcodeproj: xcodeproj, target: target)
  latest_app_store_build_number = latest_testflight_build_number
  test_flight_build_number = latest_testflight_build_number(version: version_number)

  if new_build_number <= latest_app_store_build_number
    puts "git build number is smaller than the build number of the latest release"
    puts "Using the latest release build number #{latest_app_store_build_number} + 1"
    new_build_number = latest_app_store_build_number + 1
  end

  if new_build_number <= test_flight_build_number
    puts "git build number is smaller than test flight build number"
    puts "Using the TestFlight build number #{test_flight_build_number} + 1"
    new_build_number = test_flight_build_number + 1
  end

  increment_build_number(build_number: new_build_number)
end
