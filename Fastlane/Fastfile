# rubocop:disable LineLength

require "uri"
require 'spaceship'

# Testing Lanes

desc 'Runs tests for a specific package'
desc ""
desc "#### Options"
desc " * **`package_name`**: The name of the package to test"
desc " * **`package_path`**: The path to the package"
desc ""
lane :test_package do |options|
	# Set timeout to prevent xcodebuild -list -project to take to much retries.
	ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
	ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

	begin
		reports_dir = "#{ENV['PWD']}/build/reports"

		ENV["XCPRETTY_JSON_FILE_OUTPUT"] = "#{reports_dir}/#{options[:package_name]}_Tests.json"

		# This does not work yet, see: https://github.com/fastlane/fastlane/issues/17734
		# device = options[:device] || "iPhone 11"
		# scan(
		#   scheme: options[:package_name],
		#   xcodebuild_command: "cd #{ENV['PWD']}/#{options[:package_path]} && env NSUnbufferedIO=YES xcodebuild",
		#   device: device,
		#   code_coverage: true,
		#   disable_concurrent_testing: true,
		#   fail_build: false,
		#   skip_slack: true,
		#   output_types: "",
		#   prelaunch_simulator: true,
		#   xcargs: "-UseNewBuildSystem=YES",
		#   include_simulator_logs: false, # Needed for this: https://github.com/fastlane/fastlane/issues/8909
		#   formatter: "xcpretty-json-formatter",
		#   result_bundle: true,
		#   output_directory: "build/reports/",
		#   cloned_source_packages_path: "SourcePackages",
		#   disable_package_automatic_updates: true
		# )

		destination = 'platform=iOS Simulator,name=iPhone 11'
		sourcePackagesDir = "#{ENV['PWD']}/SourcePackages"

		disable_automatic_package_resolution = options.fetch(:disable_automatic_package_resolution, true)
		extra_flags = disable_automatic_package_resolution ? "-disableAutomaticPackageResolution" : ""

		# Set the result bundle path and delete an existing one if needed.
		result_bundle_path = "#{reports_dir}/#{options[:package_name]}.xcresult"
		FileUtils.remove_dir(result_bundle_path) if File.exist?(result_bundle_path)

		#sh "cd #{ENV['PWD']}/#{options[:package_path]} && xcodebuild -showBuildSettings -clonedSourcePackagesDirPath #{sourcePackagesDir} -verbose"
	    sh "cd #{ENV['PWD']}/#{options[:package_path]} && xcodebuild -scheme #{options[:package_name]} -destination '#{destination}' -verbose -resultBundlePath '#{result_bundle_path}' -disable-concurrent-testing -enableCodeCoverage YES -UseNewBuildSystem=YES -clonedSourcePackagesDirPath #{sourcePackagesDir} #{extra_flags} test | xcpretty -f `xcpretty-json-formatter`"
	rescue => ex
		UI.important("Tests failed for #{ex}")
	end
end

desc 'Runs tests for an external project'
desc ""
desc "#### Options"
desc " * **`scheme`**: The project's scheme"
desc " * **`project_path`**: The path to the project"
desc " * **`project_name`**: The name of the project"
desc " * **`destination`**: .."
lane :test_project do |options|
	clear_derived_data

	# Set timeout to prevent xcodebuild -list -project to take to much retries.
	ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
	ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

	begin
		ENV["XCPRETTY_JSON_FILE_OUTPUT"] = "build/reports/#{options[:scheme]}_Tests.json"

		device = options[:device] || "iPhone 11"
		scan(
		  scheme: options[:scheme],
		  project: "#{options[:project_path]}#{options[:project_name]}.xcodeproj",
		  device: device,
		  destination: options[:destination],
		  code_coverage: true,
		  disable_concurrent_testing: true,
		  fail_build: false,
		  skip_slack: true,
		  output_types: "",
		  prelaunch_simulator: true,
		  xcargs: "-UseNewBuildSystem=YES",
		  include_simulator_logs: false, # Needed for this: https://github.com/fastlane/fastlane/issues/8909
		  formatter: "xcpretty-json-formatter",
		  result_bundle: true,
		  output_directory: "build/reports/",
		  cloned_source_packages_path: "SourcePackages"
		)
	rescue => ex
		UI.important("Tests failed for #{ex}")
	end
end

desc 'Tests the WeTransferPRLinter Swift Package'
lane :test_pr_linter do
	spm(command: "generate-xcodeproj", package_path: "Danger-Swift")
	test_project(
		project_path: "Danger-Swift/",
		project_name: "WeTransferPRLinter",
		scheme: "WeTransferPRLinter-Package",
		device: nil,
		destination: "platform=macOS")
end

# Deployment Lanes

desc "Creates a new release candidate"
desc ""
desc "- Creates a new TestFlight build including the unreleased changelog"
desc "- Creates a Github Draft Release including the unreleased changelog"
desc ""
desc "#### Options"
desc "It is recommended to manage these options through a .env file."
desc " * **`app_identifier`**: The bundle identifier of the main app. (`APP_IDENTIFIER`)"
desc " * **`app_identifiers`**: A comma seperated string containing all bundle identifiers, e.g. app + extensions. (APP_IDENTIFIERS)"
desc " * **`xcodeproj`**: The path to the Xcode project file. (`XCODEPROJ`)"
desc " * **`target`**: The target to build. (`XCODE_TARGET`)"
desc " * **`scheme`**: The project's scheme. (`XCODE_SCHEME`)"
desc " * **`xcconfig`**: An (optional) xcconfig file to use to build the app. (`BETA_XCCONFIG`)"
desc " * **`team_id`**: The ID of your App Store Connect team. (`FASTLANE_ITC_TEAM_ID`)"
desc " * **`contact_email`**: The contact email for beta review. (`BETA_CONTACT_EMAIL`)"
desc " * **`contact_first_name`**: The first name of the contact for beta review. (`BETA_CONTACT_FIRST_NAME`)"
desc " * **`contact_last_name`**: The last name of the contact for beta review. (`BETA_CONTACT_LAST_NAME`)"
desc " * **`contact_phone`**: The phone number of the contact for beta review. (`BETA_CONTACT_PHONE`)"
desc " * **`demo_account_name`**: The name of the demo account for beta review. (`BETA_DEMO_ACCOUNT_NAME`)"
desc " * **`demo_account_password`**: The passwords for the demo account for beta review. (`BETA_DEMO_ACCOUNT_PASSWORD`)"
desc " * **`groups`**: A list of TestFlight groups that should get access to the beta build. (`TESTFLIGHT_GROUPS_BETA`)"
lane :beta do |options|
	xcodeproj = options[:xcodeproj] || ENV["XCODEPROJ"]
	target = options[:target] || ENV["XCODE_TARGET"]
	scheme = options[:scheme] || ENV["XCODE_SCHEME"]
  tag_name = create_tag_name(xcodeproj: xcodeproj, target: target)

  if is_changed_since_last_tag == false
    slack_message(message: "A new Release is cancelled as there are no changes since the last available tag.", tag_name: tag_name)
  else
    clear_derived_data
    build_number = update_build_number(xcodeproj: xcodeproj, target: target)

    if options[:ci] || ENV['CI'] == 'true'
      certs(app_identifier: options[:app_identifiers] || ENV["APP_IDENTIFIERS"])
      decrypt_ci(path: ENV["CI_DECRYPT_SCRIPT"])
    end

    # Set timeout to prevent xcodebuild -list -project to take to much retries.
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"

    gym(
      scheme: scheme,
      configuration: "Release",
      xcconfig: options[:xcconfig] || ENV["BETA_XCCONFIG"],
      cloned_source_packages_path: "SourcePackages")

    # Create a new GitHub release
    last_non_candidate_tag = latest_github_non_candidate_tag
    release_title = "#{tag_name} - App Store Release Candidate"
    release_output = sh("gitbuddy release -l #{last_non_candidate_tag} -b develop --skip-comments --use-pre-release --target-commitish develop --tag-name #{tag_name} --release-title '#{release_title}'")
    release_url = URI.extract(release_output).find { |url| url.include? 'releases/tag' }
    puts "Created release with URL: #{release_url}"

    # Create the change log
    changelog = sh("gitbuddy changelog -b develop -s #{last_non_candidate_tag}")
    stripped_changelog = strip_markdown_url(input: changelog)
    # Refresh key as it's only valid for 20 minutes and TestFlight can take a long time.
    authenticate(use_app_manager_role: true)

    begin
      testflight(
        beta_app_review_info: {
            contact_email: options[:contact_email] || ENV["BETA_CONTACT_EMAIL"],
            contact_first_name: options[:contact_first_name] || ENV["BETA_CONTACT_FIRST_NAME"],
            contact_last_name: options[:contact_last_name] || ENV["BETA_CONTACT_LAST_NAME"],
            contact_phone: options[:contact_phone] || ENV["BETA_CONTACT_PHONE"],
            demo_account_name: options[:demo_account_name] || ENV["BETA_DEMO_ACCOUNT_NAME"],
            demo_account_password: options[:demo_account_password] || ENV["BETA_DEMO_ACCOUNT_PASSWORD"],
        },
        skip_waiting_for_build_processing: false,
        skip_submission: false,
        groups: options[:groups] || EMV["TESTFLIGHT_GROUPS_BETA"],
        changelog: stripped_changelog,
        team_id: options[:team_id] || ENV["FASTLANE_ITC_TEAM_ID"]
      )
    rescue => ex
      raise ex unless ex.message.include?('Another build is in review')
      UI.important('TestFlight delivery failed because a build is already in review, but continuing anyway!')
    end

    slack_message(message: "A new Release Candidate has been published.",tag_name: tag_name, release_url: release_url)
  end
end

desc "Creates a new App Store Release"
desc ""
desc "- Fetches the latest Github Release"
desc "- Merges the related tag into master"
desc "- Updates the changelog, creates a PR to develop for this as well"
desc "- Uses the changelog and creates a new Github App Store Release"
desc "- Submits the build to App Store Connect and TestFlight"
desc ""
desc "#### Options"
desc "It is recommended to manage these options through a .env file. "
desc " * **`app_identifier`**: The bundle identifier of the main app. (`APP_IDENTIFIER`)"
desc " * **`app_identifiers`**: A comma seperated string containing all bundle identifiers, e.g. app + extensions. (APP_IDENTIFIERS)"
desc " * **`xcodeproj`**: The path to the Xcode project file. (`XCODEPROJ`)"
desc " * **`target`**: The target to build. (`XCODE_TARGET`)"
desc " * **`scheme`**: The project's scheme. (`XCODE_SCHEME`)"
desc " * **`xcconfig`**: The xcconfig file to use to build the app, optional. (`RELEASE_XCCONFIG`)"
desc " * **`team_id`**: The ID of your App Store Connect team. (`FASTLANE_ITC_TEAM_ID`)"
desc " * **`repo`**: The name of the repository on GitHub. (`REPO_NAME`)"
desc " * **`contact_email`**: The contact email for beta review. (`BETA_CONTACT_EMAIL`)"
desc " * **`contact_first_name`**: The first name of the contact for beta review. (`BETA_CONTACT_FIRST_NAME`)"
desc " * **`contact_last_name`**: The last name of the contact for beta review. (`BETA_CONTACT_LAST_NAME`)"
desc " * **`contact_phone`**: The phone number of the contact for beta review. (`BETA_CONTACT_PHONE`)"
desc " * **`demo_account_name`**: The name of the demo account for beta review. (`BETA_DEMO_ACCOUNT_NAME`)"
desc " * **`demo_account_password`**: The passwords for the demo account for beta review. (`BETA_DEMO_ACCOUNT_PASSWORD`)"
desc " * **`groups`**: A list of TestFlight groups that should get access to the beta build. (`TESTFLIGHT_GROUPS_RELEASE`)"
desc " * **`hotfix`**: Whether the build is a hotfix release."
desc ""
lane :release do |options|
  # Get the latest released tag, merge it into master and push it to remote.
	xcodeproj = options[:xcodeproj] || ENV["XCODEPROJ"]
	target = options[:target] || ENV["XCODE_TARGET"]
	scheme = options[:scheme] || ENV["XCODE_SCHEME"]

  version_number = get_version_number(xcodeproj: xcodeproj, target: target)
  latest_release_tag = latest_github_release
  is_hotfix = options[:hotfix] || false

  begin
    ensure_release_is_needed(
      version_number: version_number,
      tag_name: latest_release_tag,
      app_identifier: options[:app_identifier] || ENV["APP_IDENTIFIER"],
    ) unless is_hotfix

    sh "git fetch --tags origin #{ENV["BITRISE_GIT_BRANCH"]} --no-recurse-submodules"

    branch_name = is_hotfix ? "hotfix/#{latest_release_tag}" : "release/#{latest_release_tag}"

    sh "git branch #{branch_name} origin/master"
    sh "git checkout #{branch_name}"

    sh "git merge -X theirs #{latest_release_tag}" unless is_hotfix

    # Update any new submodules
    sh 'git submodule sync && git submodule update --init --recursive && git submodule update --remote --no-fetch ../Submodules/WeTransfer-iOS-CI'

    update_build_number(xcodeproj: xcodeproj, target: target)
    last_non_candidate_tag = latest_github_non_candidate_tag

    # Create a new Github Release, which also merges the Changelog.md
    tag_name = create_tag_name(xcodeproj: xcodeproj, target: target)
    target_commitish = git_branch
    release_title = is_hotfix ? "#{tag_name} - App Store Hotfix Release" : "#{tag_name} - App Store Release"

    # Push the changes to our release branch so we can create a tag from it
    sh('git commit -a -m "Created a new release"')
    sh("git push origin #{branch_name}")

    release_latest_tag = is_hotfix ? latest_release_tag : last_non_candidate_tag
    release_base_branch = is_hotfix ? 'master' : 'develop'
    release_output = sh("gitbuddy release -l #{release_latest_tag} -b #{release_base_branch} -c '../Changelog.md' --target-commitish #{target_commitish} --tag-name #{tag_name} --release-title '#{release_title}' --verbose")
    release_url = URI.extract(release_output).find { |url| url.include? 'releases/tag' }
    puts "Created release with URL: #{release_url}"

    changelog = sh("gitbuddy changelog -b #{release_base_branch} -s #{release_latest_tag}")
    stripped_changelog = strip_markdown_url(input: changelog)

    # Push the updated changelog.
    sh('git commit -a -m "Created a new release"')
    sh("git push origin #{branch_name}")

    # Create a pull request for master to include the updated Changelog.md
    create_pull_request(
      api_token: ENV["DANGER_GITHUB_API_TOKEN"],
      repo: options[:repo],
      title: "Merge release #{tag_name} into master",
      base: "master", # The branch to merge the changes into.
      body: "Containing all the changes for our latest release: [#{tag_name}](#{release_url})."
    )

    # Create a pull request for develop to include the updated Changelog.md
    create_pull_request(
      api_token: ENV["DANGER_GITHUB_API_TOKEN"],
      repo: options[:repo],
      title: "Update Changelog in develop for latest release: #{tag_name}",
      base: "develop", # The branch to merge the changes into.
      body: "The changelog has been updated containing the changes from our latest release: [#{tag_name}](#{release_url})."
    )

    # Create and submit the actual build.
    clear_derived_data

    if options[:ci] || ENV['CI'] == 'true'
      certs(app_identifier: options[:app_identifiers] || ENV["APP_IDENTIFIERS"])
    end

    # Decrypt again in case any of the encrypted file changed.
    decrypt_ci(path: ENV["CI_DECRYPT_SCRIPT"])

    # Set timeout to prevent xcodebuild -list -project to take to much retries.
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "6"

    gym(
      scheme: scheme,
      configuration: "Release",
      xcconfig: options[:xcconfig] || ENV["RELEASE_XCCONFIG"],
      cloned_source_packages_path: "SourcePackages")

    # Refresh key as it's only valid for 20 minutes and TestFlight can take a long time.
    authenticate(use_app_manager_role: true)

    testflight(
      beta_app_review_info: {
          contact_email: options[:contact_email] || ENV["BETA_CONTACT_EMAIL"],
          contact_first_name: options[:contact_first_name] || ENV["BETA_CONTACT_FIRST_NAME"],
          contact_last_name: options[:contact_last_name] || ENV["BETA_CONTACT_LAST_NAME"],
          contact_phone: options[:contact_phone] || ENV["BETA_CONTACT_PHONE"],
          demo_account_name: options[:demo_account_name] || ENV["BETA_DEMO_ACCOUNT_NAME"],
          demo_account_password: options[:demo_account_password] || ENV["BETA_DEMO_ACCOUNT_PASSWORD"]
      },
      skip_waiting_for_build_processing: false,
      skip_submission: true,
      groups: options[:groups] || ENV["TESTFLIGHT_GROUPS_RELEASE"],
      changelog: stripped_changelog,
      team_id: options[:team_id] || ENV["FASTLANE_ITC_TEAM_ID"],
      verbose: true)

    # Refresh key as it's only valid for 20 minutes and TestFlight can take a long time.
    authenticate(use_app_manager_role: true)

    # Use the latest TestFlight build and submit it for review.
    deliver(
      build_number: get_build_number(xcodeproj: xcodeproj).to_s,
      submit_for_review: true,
      team_id: options[:team_id] || ENV["FASTLANE_ITC_TEAM_ID"],
      force: true, # Skip HTMl report verification
      skip_binary_upload: true, # Not needed as we use the TestFlight build.
      phased_release: true,
      automatic_release: false,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

		# Currently doesn't work because as you can't download dsyms with an API key
    # upload_dsyms

    release_type = is_hotfix ? 'hotfix' : 'release'
    slack_message(message: "A new #{release_type} has been submitted to the App Store.", tag_name: tag_name, release_url: release_url)
  rescue => ex
    UI.error ex
  end
end

desc "Creates a hotfix using the release lane. Should always be called on master"
lane :hotfix do
  release(hotfix: true)
end

desc "Returns true if there are new changes since the last available tag"
lane :is_changed_since_last_tag do
  sh "git fetch --tags origin #{ENV["BITRISE_GIT_BRANCH"]} --no-recurse-submodules"
  last_tag = last_git_tag
  changes = sh "git diff --name-only HEAD #{last_tag}"
  puts "Is local HEAD changed since last tag #{last_tag}: #{!changes.empty?}"
  is_changed = !changes.empty?
end

desc 'Create a release from a tag triggered CI run'
private_lane :release_from_tag do
	# Get the latest tag, which is the new release that triggered this lane.
	sh('git fetch --tags origin master --no-recurse-submodules -q')

	latest_tag = ENV["BITRISE_GIT_TAG"]
	
	# Create a release branch
	sh "git branch release/#{latest_tag} origin/master"
    sh "git checkout release/#{latest_tag}"
    sh "git merge -X theirs #{latest_tag}"

	release_output = sh('gitbuddy release -c "../Changelog.md"')
	release_url = URI.extract(release_output).find { |url| url.include? 'releases/tag' }
    puts "Created release with URL: #{release_url}"

	# Run only if there's a podspec to update
	if Dir['../*.podspec'].any?
		# Update the podspec. It finds the .podspec automatically in the current folder.
		version_bump_podspec(version_number: latest_tag)
		
		begin
			# Push the podspec to trunk
			pod_push
		rescue => ex
			UI.important("Pod push failed: #{ex}")
		end
	end

	# Push the changes to the branch
	sh('git commit -a -m "Created a new release"')
    sh("git push origin release/#{latest_tag}")
	
	# Create a PR
    # Create a pull request for master to include the updated Changelog.md and podspec
    create_pull_request(
      api_token: ENV["DANGER_GITHUB_API_TOKEN"],
      repo: git_repository_name,
      title: "Merge release #{latest_tag} into master",
      base: "master", # The branch to merge the changes into.
      body: "Containing all the changes for our [**#{latest_tag} Release**](#{release_url})."
    )
end

desc "Unhide dev dependencies for danger"
lane :unhide_spm_package_dev_dependencies do
	text = File.read('../Package.swift')
	new_contents = text.gsub('// dev ', "")

	# To write changes to the file, use:
	File.open('../Package.swift', "w") {|file| file.puts new_contents }
end

desc "Returns the repository name. E.g: WeTransfer/Mocker"
private_lane :git_repository_name do
	sh("git remote show origin -n | grep h.URL | sed 's/.*://;s/.git$//'").strip
end

desc "Get latest release from Github. Draft releases and prereleases are not returned by this endpoint. See: https://developer.github.com/v3/repos/releases/#get-the-latest-release"
lane :latest_github_release do
	origin_name = git_repository_name.split('/')
	organisation = origin_name[0]
	repository = origin_name[1]

	result = github_api(
		server_url: "https://api.github.com",
		api_token: ENV["DANGER_GITHUB_API_TOKEN"],
		http_method: "GET",
		path: "/repos/#{organisation}/#{repository}/releases/latest"
	)

	puts "Latest Github release is #{result[:json]["tag_name"]}"
	result[:json]["tag_name"]
end

desc "Get all changed files in the current PR"
desc "Requires that the enviroment contains a Danger GitHub API token `DANGER_GITHUB_API_TOKEN`"
desc ""
desc "#### Options"
desc " * **`pr_id`**: The identifier of the PR that contains the changes."
desc ""
lane :changed_files_in_pr do |options|
	origin_name = git_repository_name.split('/')
	organisation = origin_name[0]
	repository = origin_name[1]

	if options[:pr_id].nil?
		raise "Missing PR ID input"
	elsif ENV["DANGER_GITHUB_API_TOKEN"].nil?
		raise "Missing 'DANGER_GITHUB_API_TOKEN' environment variable"
	end

	puts "Fetching changed files for PR #{options[:pr_id]} using token ...#{ENV["DANGER_GITHUB_API_TOKEN"].chars.last(5).join}"

	result = github_api(
		server_url: "https://api.github.com",
		api_token: ENV["DANGER_GITHUB_API_TOKEN"],
		http_method: "GET",
		path: "/repos/#{organisation}/#{repository}/pulls/#{options[:pr_id]}"
	)

	baseRef = result[:json]["base"]["ref"]

	# As CI fetches only the minimum we need to fetch the remote to make diffing work correctly.
	sh 'git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"'
	sh "git fetch --no-recurse-submodules --no-tags"
	sh "git diff --name-only HEAD origin/#{baseRef}"
end

desc "Check whether any of the changes happened in the given path"
desc ""
desc "#### Options"
desc " * **`path`**: The path to check for"
desc ""
lane :pr_changes_contains_path do |options|
  changes_contains_path = options[:changed_files].include?(options[:path])

  if changes_contains_path
  	puts "Changes found for path #{options[:path]}"
  elsif
	puts "No changes found for path #{options[:path]}"
  end
  	
  changes_contains_path
end

desc "Updates the build number of the project based on the commit count"
desc ""
desc "#### Options"
desc " * **`xcodeproj`**: the path to the Xcode project to read the version number from"
desc " * **`target`**: The target within the project to read the version number from"
desc ""
private_lane :update_build_number do |options|
	# Get the path to the Xcode project and the target to read the version number from.
	xcodeproj = options[:xcodeproj]
	target = options[:target]

  # Compute a new build number based on the commit count.
	build = sh "git rev-list --all --count"
  new_build_number = 200 + Integer(build)

	# Fetch the build number of the most recent test flight build, to make sure
	# that the new build number will be higher.
  version_number = get_version_number(xcodeproj: xcodeproj, target: target)
  latest_app_store_build_number = latest_testflight_build_number
  test_flight_build_number = latest_testflight_build_number(version: version_number)

  if new_build_number <= latest_app_store_build_number
    puts "git build number is smaller than the build number of the latest release"
    puts "Using the latest release build number #{latest_app_store_build_number} + 1"
    new_build_number = latest_app_store_build_number + 1
  end

  if new_build_number <= test_flight_build_number
    puts "git build number is smaller than test flight build number"
    puts "Using the TestFlight build number #{test_flight_build_number} + 1"
    new_build_number = test_flight_build_number + 1
  end

  increment_build_number(build_number: new_build_number)
end

desc "Syncs production certificates on CI"
desc ""
desc "#### Options"
desc " * **`app_identifier`**: a list of all app identifiers for which to sync the certs"
desc ""
private_lane :certs do |options|
  # Create Keychain to store certificates in
  create_keychain(
    name: ENV["MATCH_KEYCHAIN_NAME"],
    password: ENV["MATCH_KEYCHAIN_PASSWORD"],
    default_keychain: true,
    unlock: true,
    timeout: 3600,
    add_to_search_list: true)
  # Sync certificates
  match(
    keychain_name: "#{ENV["MATCH_KEYCHAIN_NAME"]}",
    keychain_password: "#{ENV["MATCH_KEYCHAIN_PASSWORD"]}",
    app_identifier: options[:app_identifier],
    force: true,
    type: "appstore")
end

desc "Fetch the version number that's currently in prepare for submission mode in App Store Connect."
desc ""
desc "#### Options"
desc " * **`app_identifier`**: The bundle identifier of the app for which to fetch the preparing version number"
desc ""
private_lane :current_preparing_app_version do |options|
  puts 'fetching highest version on App Store Connect...'

  token = Spaceship::ConnectAPI::Token.create(Actions.lane_context[SharedValues::APP_STORE_CONNECT_API_KEY])
  Spaceship::ConnectAPI.token = token

  app = Spaceship::ConnectAPI::App.find(options[:app_identifier])

  if app.nil?
    puts 'App not found'
    next
  end

  if app.get_edit_app_store_version.nil?
    puts 'No preparing version number found'
    next
  end

  puts "Latest perparing version is #{app.get_edit_app_store_version.version_string}"

  app.get_edit_app_store_version.version_string
end

desc "Ensures that a new release is allowed to happen"
desc ""
desc "#### Options"
desc " * **`app_identifier`**: The bundle identifier of the app for which to fetch the preparing version number"
desc " * **`version_number`**: The version number of the project"
desc " * **`tag_name`**: The name of the latest release on GitHub"
desc ""
private_lane :ensure_release_is_needed do |options|
  preparing_app_version = current_preparing_app_version(app_identifier: options["app_identifier"])

  if preparing_app_version.nil?
    message = 'Weekly release cancelled as App Store Connect does not contain a preparing app version'
    UI.important message
    slack(
      message: message,
      success: false,
      default_payloads: [:git_branch, :last_git_commit_message]
    )

    raise message
  end

  local_project_version_number = Gem::Version.new(options[:version_number])
  tag_version_number = Gem::Version.new(options[:tag_name].split('b')[0])

  app_store_preparing_version = Gem::Version.new(preparing_app_version)

  project_version_is_newer = tag_version_number < local_project_version_number
  preparing_version_is_newer = tag_version_number < app_store_preparing_version

	# Cancel when did not manage to create a stable release on GitHub or when the App Store Connect preparing version doesn't match the project version.
  if project_version_is_newer || preparing_version_is_newer
    UI.important "Release cancelled. Tag version: #{tag_version_number}, project version: #{local_project_version_number}, app store preparing version: #{app_store_preparing_version}"

    slack(
      message: "Weekly released cancelled as no new green light build is available.",
      success: false,
      default_payloads: [:git_branch, :last_git_commit_message],
      payload: {
        "Latest available release tag" => tag_version_number
      }
    )

    raise "Weekly released cancelled as no new green light build is available."
  end
end

desc "Get latest release from Github that is not a prelease or release candidate"
private_lane :latest_github_non_candidate_tag do
  origin_name = git_repository_name.split('/')
  organisation = origin_name[0]
  repository = origin_name[1]

  result = github_api(
    server_url: "https://api.github.com",
    api_token: ENV["DANGER_GITHUB_API_TOKEN"],
    http_method: "GET",
    path: "/repos/#{organisation}/#{repository}/releases"
  )
  latest_release = result[:json].find { |release| !release["name"].downcase.include? "candidate" }
  latest_release["tag_name"]
end

desc "Strips Markdown URLs and returns it as plain text"
desc "Used for example for the App Store changelog"
desc "#### Options"
desc " * **`input`**: The text from which to strip the Markdown URLs"
desc ""
private_lane :strip_markdown_url do |options|
  options[:input].gsub(/(?:__|[*#])|\[(.*?)\]\(.*?\)/, '\1')
end

desc "Generates a new tag name using the projects build and version number"
desc ""
desc "#### Options"
desc " * **`xcodeproj**: The name of the Xcode project to use to get the build and version number"
desc " * **`target`**: The Xcode target to use to get the build and version number"
desc ""
private_lane :create_tag_name do |options|
  version_number = get_version_number(xcodeproj: options[:xcodeproj], target: options[:target])
  build_number = get_build_number(xcodeproj: options[:xcodeproj])
  tag_name = version_number + "b" + build_number
end

desc "Posts a message about the status of a build to Slack"
desc "It is required to create an incoming Webhook for Slack and set this as an environment variable `SLACK_URL`"
desc ""
desc "#### Options"
desc " * **`message**`: The message to post to Slack"
desc "* **`tag_name**`: The name of the tag associated with the build"
desc " * **`release_url`**: The url to a GH release."
desc ""
lane :slack_message do |options|
  slack(
      message: "#{options[:message]} (#{options[:tag_name]})",
      success: true,
      default_payloads: [:git_branch, :last_git_commit_message],
      payload: {
        "Release URL" => options[:release_url]
      }
  )
end

desc "Decrypts the encrypted files on CI."
desc ""
desc "#### Options"
desc " * **`script`**: The path to the bash script that needs to be executed to decrypt the files"
desc ""
lane :decrypt_ci do | options |
  sh(options[:path])
end

desc "Loads the JWT token that is used to authenticate with the App Store Connect API"
desc ""
desc "#### Options"
desc " * **`use_app_manager_role`**: Whether it should use the token with the App Manager Role or Developer Role. This is needed when you want to upload metadata in addition to a build, e.g. app metadata when submitting to Test Flight."
desc ""
desc "This lane makes use of the following environment variables:"
desc " - `JWT_ISSUER_ID`: The identifier of the issuer of the JWT token"
desc " - `APP_MANAGER_KEY_ID`: The id of the JWT token used to authenticate with an App manager role"
desc " - `DEVELOPER_KEY_ID`: The id of the JWT token used to authenticate with an App manager role"
desc " - `APP_MANAGER_KEY_PATH`: The path to the file containing the private key"
desc " - `DEVELOPER_KEY_PATH`: The path to the file containing the private key"
desc ""
lane :authenticate do | options |
	use_app_manager_role = options[:use_app_manager_role] || false
	key_id = use_app_manager_role ? ENV["APP_MANAGER_KEY_ID"] : ENV["DEVELOPER_KEY_ID"]
	key_filepath = use_app_manager_role ? ENV["APP_MANAGER_KEY_PATH"] : ENV["DEVELOPER_KEY_PATH"]
	issuer_id = ENV["JWT_ISSUER_ID"]

	UI.important "Authenticating using #{use_app_manager_role ? "App Manager Role" : "Developer Role"}"

  app_store_connect_api_key(
    key_id: key_id,
    issuer_id: issuer_id,
    key_filepath: key_filepath,
    duration: 1200, # 90 minutes, matching Bitrise timeout limit.
    in_house: false, # optional but may be required if using match/sigh
  )
end
